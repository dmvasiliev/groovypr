Groovy

· Синтаксис языка, отличие от Java

· Closure

· Работа с коллекциями

· Работа с файлами

· Запуск Groovy Script

· Запуск Groovy Expression

· Метапрограммирование

· GroovyConsole

http://www.groovy-lang.org/single-page-documentation.html https://github.com/spockframework/spock-example

Задачи:

1.1 Дана строка, состоящая из слов.

а. найти все слова, содержащие только буквы нижнего регистра;

б. вывести символы с 11-го по 16-ый (с учетом, что строка больше 16 символов);

в. вывести все буквы английского алфавита (нижний регистр);

г. поменять во всех словах строки первую букву на заглавную;

д. найти все слова, реверсия которых (обратный порядок букв) идентична самому слову и количество различных букв (исключая повторения) в слове меньше 5.

(пример:

'bob', 'reviver', 'rotator')

е. определить, содержит ли строка электронный адрес;

1.2 Дан неупорядоченый массив чисел.

а. найти количество различных чисел;

б. найти максимальное и минимальное число;

в. увеличить каждое число в 2 раза если оно положительное

и в три раза если оно отрицательное;

г. имеется второй массив неупорядоченных чисел: определить числа,

входящие и в первый и во второй массив;

2.1. Просканировать заданную папку на диске. Найти все файлы, подпадающие под шаблон:

название файла (без учета расширения) заканчивается словом 'groovy'.

Результат поиска представить в виде списка записей и вывести его.

Запись имеет вид типа:

FileName

Quantity Files(количество файлов в вложенных папках соответствующие введенному шаблону)

Size (in kb)

2.2. Вывести (представить) записи (полученный в результате работы предыдущей задачи)

в формате XML (see Groovy MarkupBuilder).

3.1. В заданной папке найти все файлы с расширением TXT, содержащие в названии только цифры:

для каждого такого файла поменять название на

[обратный порядок цифр]_[сумма цифр].dat

Пример:

12356.txt -> 65321_17.dat

----------------------------------------------------------------------------------------------------------------

4.1. Добавить к классу Integer и интерфейсу List несколько методов (один из них должен быть статическим),

используя возможности метапрограммирования в Groovy;

4.2. Задать объект, типа Сlosure, который принимает несколько параметров (Integer, String, Closure). Затем вызвать closure явным и неявным образом.

В чем отличие метода от closure?

4.3. Написать класс Person (с некоторым набором свойств, к примеру firstName, surName, address (city, street, index) , age);

1.3.1. Определить для объектов класса методы '+', '-';

1.3.2. Определить метод toString, который выводит "${firstName}, ${surName}"

1.3.3. Среди объектов типа Person найти такие, у которых возраст (age) менее 30 лет;

1.3.4. Вывести все различные адреса, которые есть у списка объектов Person;

1.3.5. Переопределить метод toString, не меняя описания класса Person (к примеру теперь пусть выводит "${surName} ${firstName} (${age})").

5. Есть некоторая переменная, например Integer number = 0; написать запуск нескольких процессов (стартуем к примеру 10 потоков подряд), каждый из которых

пробует доступиться к этой переменной, увеличить её значение на 1 и затем засыпает на 100 млсекунд.

6. Написать метод( или кложе), который делает рекурсивное удаление всех вложенных файлов (не директории!).

7. Операторы:

7.1. Возвести число 4 в 5 степень;

7.2. Написать closure printValue,которое если аргумент не null выводит его значение, иначе выводит 'no value'(без оператора 'if')

7.3. У каждого объекта Person вывести значение index (свойство адреса), учитывая что у некоторых объектов Person адреса нету (без оператора 'if')

8. Запуск Скриптов

· Запуск скрипта

· Компиляция скриптов и их запуск, сравнение производительности

· Передача параметров

· Import других классов в скрипт

·

9. Чтение больших файлов

- Есть большой xml файл - 1 GB Структуры

<xml>

<field name="SOME NAME">

SOME Value

</field>

.....

</xml>

Необходимо пройтись по нему и найти количество полей (field) значение которых соответствует введенному значению.

* Для проверки результатов задач должны быть использованы (Spock) тесты,

** Максимально использовать Groovy